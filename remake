#!/bin/bash

set -e

SCRIPT_PATH="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_PATH}" ]) then
  while([ -h "${SCRIPT_PATH}" ]) do SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
pushd . > /dev/null
cd `dirname "${SCRIPT_PATH}"` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null
#SCRIPT_PATH=$(cd `dirname $0`; pwd)

escape()
{
echo "$1"| sed -e "s/ /\\\\\\ /g"
}

usage()
{
cat << EOF
usage: $0 [options] file [command]

This script generates Makefile and renders your animation project taking all 
dependencies into account.

OPTIONS:
  -f <format>   Force output format.
  -h            Show this message.
  -k            Keep Makefile so you can skip dependency detection and re-invoke 
                rendering by typing 'make'.
  -s            Render stereoscopic 3D (side-by-side).
  -t <threads>  Specify the amount of rendering jobs to be run in parallel. 
                Use zero for no limit.

COMMANDS:
  snapshot      Additionally save snapshot of the current rendering as video file
                in the 'snapshots/' subdirectory in the project tree.
  clean         Remove all rendered footage associated with the file.
  deps          Render all dependencies of the given file, but not the file itself.
EOF
}

relpath(){
	if [[ "$1" == "$2" ]]
	then
		echo "."
	fi

	IFS="/"

	current=($1)
	absolute=($2)

	abssize=${#absolute[@]}
	cursize=${#current[@]}

	while [[ ${absolute[$level]} == ${current[$level]} ]]
	do
		(( level++ ))
		if (( level > abssize || level > cursize ))
		then
			break
		fi
	done

	for ((i = level; i < cursize; i++))
	do
		if ((i > level))
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath".."
	done

	for ((i = level; i < abssize; i++))
	do
		if [[ -n $newpath ]]
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath${absolute[i]}
	done

	echo "$newpath"
}

get_project_root() {
	if [ -d "$1" ]; then
		pushd "$1" >/dev/null
		TESTDIR=`pwd -P`
		popd >/dev/null
	else
		TESTDIR="$1"
	fi
	if [ -f "$TESTDIR/remake.conf" ]; then
		echo $TESTDIR
	else
		if [[ "$TESTDIR" == '/' ]]; then
			echo "   ERROR: Not a 'remake' project." 1>&2
			exit
		fi
		get_project_root "`dirname \"$TESTDIR\"`"
	fi
}

write_rules(){
	
	PROJECTROOT=$(get_project_root "`dirname \"$1\"`")
	pushd "`dirname "$1"`" >/dev/null
	RENDERPREFIX=$(pwd -P | sed -e "s|$PROJECTROOT||")
	[ -d "$PROJECTROOT/render${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/render${RENDERPREFIX}"
	TARGETDIR=`pwd -P`
	popd  >/dev/null
	
	CONFIGPATH=$(relpath "`pwd -P`" "$PROJECTROOT/remake.conf")
	
	# Ensure that render dir ignored by git
	[ -e "$PROJECTROOT/.gitignore" ] || touch "$PROJECTROOT/.gitignore"
	( cat "$PROJECTROOT/.gitignore" | egrep "render/\*" > /dev/null ) || ( echo "render/*" >> "$PROJECTROOT/.gitignore" )
	( cat "$PROJECTROOT/.gitignore" | egrep "snapshots/\*" > /dev/null ) || ( echo "snapshots/*" >> "$PROJECTROOT/.gitignore" )
	
	TARGET=$(relpath "`pwd -P`" "$TARGETDIR")/`basename "$1"`
	EXT=${TARGET##*.}
	
	# Defaults
	FORMAT=png
	UPDATE=0
	
	# Re-reading config
	. "$PROJECTROOT/remake.conf"
	
	DEPS=`escape "$CONFIGPATH"`
	SINGLE=''
	
	export FORMAT
	
	# allow module to override format
	if [ -f "$SCRIPT_PATH/modules/mod_$EXT" ]; then
		FORMAT=`bash -e "$SCRIPT_PATH/modules/mod_$EXT" format`
	fi
	
	# Looking for extra settings
	if [ -e "${TARGET}.conf" ]; then
		. "${TARGET}.conf"
		DEPS="$DEPS `escape "${TARGET}.conf"`"
	fi
	
	# Format can be overriden by commandline option
	if [ ! -z "$3" ]; then
		FORMAT="$3"
	fi
	
	# Format should be forced to PNG if snapshot is requested
	if [[ "$2" == 'snapshot' && $FORMAT != 'mpg' && $FORMAT != 'avi' ]]; then
		FORMAT=png
	fi
	
	RENDERPATH=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`.$FORMAT
	
	# check if rules for this target are already written
	#echo $RENDERPATH
	
	
	if ! ( cat "$MAKEFILE" | grep -E "^$RENDERPATH:" >/dev/null ); then
	
	echo "Retrieving deps for '$TARGET'..."
	
	export WIDTH
	export HEIGHT
	export FORMAT
	export FPS
	export SINGLE
	export UPDATE
	
	export TARGET
	export RENDERPATH
	
	export MAKEFILE
	
	
	PENDINGTARGETS=''
	if [ ! -f "$SCRIPT_PATH/modules/mod_$EXT" ]; then
		echo "   WARNING: Don't know how to handle file with $EXT extension."
		echo "            Skipping."
	else
		#bash -x "$SCRIPT_PATH/modules/mod_$EXT" deps
		RAWDEPS=`bash -e "$SCRIPT_PATH/modules/mod_$EXT" deps`
		# Removing duplicates
		RAWDEPS=`echo "$RAWDEPS" | sort -u`
		# Check for new render targets
		if [ ! -z "$RAWDEPS" ];then
		while read LINE; do
			DIR=`dirname "$LINE"`
			if [ ! -e "$DIR" ]; then
				# go one level down, because render result could be a 
				# sequence in dir which is not exists
				DIR=`dirname "$DIR"`
			fi
			EXTPROJECTROOT=`get_project_root "$DIR"`
			if [[ $EXTPROJECTROOT == "" ]]; then
				# Report files outside of the repo
				echo "   $LINE"
				echo "   WARNING: '$LINE' is not belongs to any project."
				echo "            Skipping."
			else
				[ -e "`dirname "$LINE"`" ] || mkdir -p "`dirname "$LINE"`"
				pushd "`dirname "$LINE"`" >/dev/null
				DEPDIR=`pwd -P`
				popd >/dev/null
				LINE="$(relpath "`pwd -P`" "$DEPDIR")/`basename "$LINE"`"
				#LINE=$(relpath `pwd` $LINE)
				echo "   $LINE"
				if ( echo $DEPDIR | grep -E "^${EXTPROJECTROOT}/render/" > /dev/null ); then
					
					#pushd `dirname $LINE` >/dev/null
					#DEPDIR=`pwd`
					#popd >/dev/null
					#DEP=$(relpath `pwd` $DEPDIR)/`basename $LINE`
					#LINE=`echo "$LINE"| sed -e "s/ /\\\\\\\\ /g"`
					#LINE=`echo "$LINE"| sed -e "s/\\\\\\ / /g"`
					echo "   INFO: Dependency '$LINE' defines another target."
					
					TARGETCANDIDATE=`echo $DEPDIR/$(basename "${LINE%.*}") | sed -e "s|^${EXTPROJECTROOT}/render/|${EXTPROJECTROOT}/|" `
					if [ ! -e "$TARGETCANDIDATE" ]; then
						TMP=$TARGETCANDIDATE
						TARGETCANDIDATE=`dirname "${TARGETCANDIDATE}"`
						TARGETCANDIDATE=${TARGETCANDIDATE%.*}
						echo "   INFO: Trying to fix '$TMP' to '$TARGETCANDIDATE'."
						
						if [ -d "$TARGETCANDIDATE" ]; then
							echo "         ERROR: Can't define target from directory."
						else
							if [ ! -e "$TARGETCANDIDATE" ]; then
								echo "   ERROR: Not found!"
							else
								echo "         Successfull."
								LINE=`dirname "$LINE"`
							fi
						fi
					fi
					
					DEPS="$DEPS `escape "$LINE"`"
					
					if [ -e "$TARGETCANDIDATE" ] && [ ! -d "$TARGETCANDIDATE" ]; then
						#TARGETCANDIDATE=`echo "$TARGETCANDIDATE"| sed -e 's/ /\\\\\\\\ /g'`
						PENDINGTARGETS=$(echo -e "$PENDINGTARGETS\n$TARGETCANDIDATE")
					fi
				else
					if [ ! -e "$LINE" ]; then
						# Report non-existing files
						echo "   WARNING: '$LINE' is not exists and not produced by any target."
						echo "            Skipping."
					else
						#pushd `dirname $LINE` >/dev/null
						#DEPDIR=`pwd`
						#popd >/dev/null
						#DEPS="$DEPS $(relpath `pwd` $DEPDIR)/`basename $LINE`"
						#LINE=`echo "$LINE"| sed -e "s/ /\\\\\\ /g"`
						DEPS="$DEPS `escape "$LINE"`"
					fi
				fi
			fi
		done < <( echo "$RAWDEPS" )
		fi
		
		export DEPS
		
		# Allow to override rules per file
		if [ -e "${TARGET}.make" ]; then
			echo "`escape "$RENDERPATH"`: `escape "$TARGET"` $DEPS" >> "$MAKEFILE"
			echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"`" >> "$MAKEFILE"
			echo "`escape "$RENDERPATH"`-clean:" >> "$MAKEFILE"
			echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"` clean" >> "$MAKEFILE"
		else
			bash -e "$SCRIPT_PATH/modules/mod_$EXT" rules
		fi
		
		if [[ "$2" == 'deps' ]]; then
			echo ".PHONY: deps" >> "$MAKEFILE"
			echo "deps: $DEPS" >> "$MAKEFILE"
		fi
		
		echo ".PHONY: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
		echo "clean: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
		
		# "Snapshot" rule
		if [[ "$2" == 'snapshot' ]]; then
			[ -d "$PROJECTROOT/snapshots${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/snapshots${RENDERPREFIX}"
			
			# SCM detection
			pushd "$PROJECTROOT/${RENDERPREFIX}" >/dev/null
			if git rev-parse --git-dir > /dev/null  2>&1 ; then
				COMMITID=$(git show --pretty=oneline|head -n 1|sed 's/ .*//')
				COMMITID="-$COMMITID"
			fi
			popd >/dev/null
			
			SNAPSHOTPATH=$(relpath "`pwd -P`" "$PROJECTROOT/snapshots${RENDERPREFIX}")/`basename "$TARGET"`-`date +%Y%m%d-%H%M%S`${COMMITID}
			echo "snapshot: `escape "$SNAPSHOTPATH"`" >> "$MAKEFILE"
			echo "`escape "$SNAPSHOTPATH"`: `escape "$RENDERPATH"`" >> "$MAKEFILE"
			if [[ $FORMAT == 'mpg' ]] || [[ $FORMAT == 'avi' ]]; then
				echo "	cp -f \"${RENDERPATH}\" \"${SNAPSHOTPATH}.$FORMAT\"" >> "$MAKEFILE"
			else
				echo "	ffmpeg -i \"${RENDERPATH}/file.%04d.png\" -sameq -r $FPS \"${SNAPSHOTPATH}.avi\"" >> "$MAKEFILE"
			fi
			echo ".PHONY: snapshot" >> "$MAKEFILE"
		fi
		
		while read TARGET; do
			if [ ! -z "$TARGET" ];then
				write_rules "$TARGET"
			fi
		done < <( echo "$PENDINGTARGETS" )
	fi
	fi
}

OPT_KEEP=0
OPT_MODE="normal"
THREADS=1
while getopts "f:hks:t:" OPTION
do
     case $OPTION in
         f)
             OPT_FORMAT="$OPTARG"
             ;;
         h)
             usage
             exit 1
             ;;
         k)
             OPT_KEEP=1
             ;;
         s)
             OPT_MODE="stereo"
             ;;
         t)
             THREADS="$OPTARG"
             if [[ $THREADS == 0 ]]; then
                THREADS=''
             fi
             ;;
         ?)
             usage
             exit
             ;;
     esac
done

shift $(($OPTIND - 1))

if [ -z "$1" ]; then
	echo
	echo "ERROR: Please specify filename to render. Aborting." >&2
	echo
	usage
	exit 1
fi

if [ ! -f "$1" ]; then
	echo
	echo "ERROR: No such file. Aborting." >&2
	echo
	exit 1
fi

if [[ "$2" == 'snapshot' ]]; then
	if ! ( which ffmpeg > /dev/null 2>&1 ); then
	echo "   FATAL: Can't find 'ffmpeg' binary!" >&2
	exit 1
fi
fi

PROJECTROOT=$(get_project_root "`dirname \"$1\"`")

[ -d "${PROJECTROOT}/render/tmp" ] || mkdir -p "${PROJECTROOT}/render/tmp"
MAKEFILE=${PROJECTROOT}/render/tmp/Makefile.$$
[ ! -e "$MAKEFILE" ] || rm "$MAKEFILE"
touch "$MAKEFILE"

echo
echo "==============================================="
echo "       First stage: Analyzing files"
echo "==============================================="
echo

write_rules "$1" "$2" "$OPT_FORMAT"
echo ".PHONY: clean" >> "$MAKEFILE"

[[ $OPT_KEEP == 0 ]] || cp -f "$MAKEFILE" Makefile

echo
echo "==============================================="
echo "       Second stage: Rendering"
echo "==============================================="
echo

echo "Running make..."
make -f "$MAKEFILE" -j $THREADS $2
rm -f "$MAKEFILE"
