#!/bin/bash

set -e

# First check required software
if ! ( which make > /dev/null 2>&1 ); then
	cat <<EOF
   FATAL: Can't find 'make' binary!
   
          Please install 'make' package using software manager of 
          your linux distributive.
EOF
	exit 1
fi

# Then initialize basic variables

SCRIPT_PATH="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_PATH}" ]) then
  while([ -h "${SCRIPT_PATH}" ]) do SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
pushd . > /dev/null
cd `dirname "${SCRIPT_PATH}"` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null
#SCRIPT_PATH=$(cd `dirname $0`; pwd)

MODULES_PATH=$SCRIPT_PATH/modules
if [ ! -d "$MODULES_PATH" ]; then
	#fix path for local installation
	MODULES_PATH=$SCRIPT_PATH/../lib/remake/modules
fi

TESTDATA_PATH=$SCRIPT_PATH/tests
if [ ! -d "$TESTDATA_PATH" ]; then
	#fix path for local installation
	TESTDATA_PATH=$SCRIPT_PATH/../share/remake/tests
fi
export TESTDATA_PATH

#Init traps
trap do_cleanup INT

escape()
{
echo "$1"| sed -e "s/ /\\\\\\ /g"
}

abspath(){
	readlink -m "$1"
}

usage()
{
cat << EOF
usage: $0 [options] file [command]

This script generates Makefile and renders your animation project taking all 
dependencies into account.

OPTIONS:
  -c <camera>   Select camera to render from (if applicable).
  -f <format>   Force output format.
  -h            Show this message.
  -k            Keep Makefile so you can skip dependency detection 
                and re-invoke rendering by typing 'make'.
  -t <threads>  Specify the amount of rendering jobs to be run 
                in parallel. Use zero for no limit.

COMMANDS:
  clean         Remove all rendered footage associated with the file.
  deps          Render all dependencies of the given file, but not 
                the file itself.
  pack          Pack into zip file together with all dependencies.
                Resulting file will reside the 'packs/' subdirectory
                of the project tree.
  snapshot      Additionally save snapshot of the current rendering 
                as video file in the 'snapshots/' subdirectory of
                the project tree.
  stereo        Render stereoscopic 3D (side-by-side).
EOF
}

relpath(){
	if [[ "$1" == "$2" ]]
	then
		echo "."
	fi

	IFS="/"

	current=($1)
	absolute=($2)

	abssize=${#absolute[@]}
	cursize=${#current[@]}

	while [[ ${absolute[$level]} == ${current[$level]} ]]
	do
		(( level++ ))
		if (( level > abssize || level > cursize ))
		then
			break
		fi
	done

	for ((i = level; i < cursize; i++))
	do
		if ((i > level))
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath".."
	done

	for ((i = level; i < abssize; i++))
	do
		if [[ -n $newpath ]]
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath${absolute[i]}
	done

	echo "$newpath"
}

get_project_root() {
	if [ -d "$1" ]; then
		pushd "$1" >/dev/null
		TESTDIR=`pwd -P`
		popd >/dev/null
	else
		TESTDIR="$1"
	fi
	if [ -f "$TESTDIR/remake.conf" ]; then
		echo $TESTDIR
	else
		if [[ "$TESTDIR" == '/' ]]; then
			echo "   ERROR: Not a 'remake' project." 1>&2
			exit
		fi
		get_project_root "`dirname \"$TESTDIR\"`"
	fi
}

do_cleanup(){
	echo
	echo "Cleaning up..."
	rm -f "$MAKEFILE"
	[ ! -e "${PACKFILE}.lst" ] || rm "${PACKFILE}.lst"
	[ ! -e "${PACKFILE}.lst2" ] || rm "${PACKFILE}.lst2"
	# Remove modules check flags
	rm -rf "${CHECK_PATH}" || true
}

write_rules(){
	
	PROJECTROOT=$(get_project_root "`dirname \"$1\"`")
	if [[ "$PROJECTROOT" == "" ]]; then
		exit 1
	fi
	pushd "`dirname "$1"`" >/dev/null
	RENDERPREFIX=$(pwd -P | sed -e "s|$PROJECTROOT||")
	[ -d "$PROJECTROOT/render${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/render${RENDERPREFIX}"
	# TARGETDIR - path to TARGET relative to project root
	TARGETDIR=$(relpath "$PROJECTROOT" "`pwd -P`")
	popd  >/dev/null
	
	CONFIGPATH=$(relpath "`pwd -P`" "$PROJECTROOT/remake.conf")
	# Data packing
	[ -d "$PROJECTROOT/packs" ] || mkdir -p "$PROJECTROOT/packs"
	echo "${PROJECTROOT}/remake.conf" >>"${PACKFILE}.lst"
	
	# Ensure that render dir ignored by git
	[ -e "$PROJECTROOT/.gitignore" ] || touch "$PROJECTROOT/.gitignore"
	( cat "$PROJECTROOT/.gitignore" | egrep "render/\*" > /dev/null ) || ( echo "render/*" >> "$PROJECTROOT/.gitignore" )
	( cat "$PROJECTROOT/.gitignore" | egrep "snapshots/\*" > /dev/null ) || ( echo "snapshots/*" >> "$PROJECTROOT/.gitignore" )
	( cat "$PROJECTROOT/.gitignore" | egrep "packs/\*" > /dev/null ) || ( echo "packs/*" >> "$PROJECTROOT/.gitignore" )
	
	TARGET=$(relpath "`pwd -P`" "$PROJECTROOT/$TARGETDIR")/`basename "$1"`
	EXT=${TARGET##*.}
	
	# Defaults
	FORMAT=png
	UPDATE=0
	
	# Re-reading config
	. "$PROJECTROOT/remake.conf"
	
	if [ -z $AUDIO_RATE ]; then
		AUDIO_RATE=48000
	fi
	
	DEPS=`escape "$CONFIGPATH"`
	SINGLE=''
	
	export FORMAT
	
	# give module a chance to override format
	if [ -f "$MODULES_PATH/mod_$EXT" ]; then
		FORMAT=`bash -e "$MODULES_PATH/mod_$EXT" format`
	fi
	
	# Looking for extra settings
	if [ -e "${TARGET}.conf" ]; then
		. "${TARGET}.conf"
		DEPS="$DEPS `escape "${TARGET}.conf"`"
		# Data packing
		echo $(abspath "${TARGET}.conf") >>"${PACKFILE}.lst"
	fi
	
	# Format can be overriden by commandline option
	if [ ! -z "$3" ]; then
		FORMAT="$3"
	fi
	
	# Format should be forced to PNG if snapshot is requested
	if [[ "$2" == 'snapshot' && $FORMAT != 'mpg' && $FORMAT != 'avi' ]]; then
		FORMAT=png
	fi
	
	RENDERPATH=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`.$FORMAT
	
	# check if rules for this target are already written
	#echo $RENDERPATH
	
	
	if ! ( cat "$MAKEFILE" | grep -E "^$RENDERPATH:" >/dev/null ); then
	
	echo "Retrieving deps for '$TARGET'..."
	
	export WIDTH
	export HEIGHT
	export FPS
	export SINGLE
	export UPDATE
	export AUDIO_RATE
	
	export TARGET
	export RENDERPATH
	export PROJECTROOT
	
	export MAKEFILE
	
	# check module requirements
	if [ -f "$MODULES_PATH/mod_$EXT" ]; then
		if [ ! -e "${CHECK_PATH}/mod_$EXT" ]; then
			echo
			echo "Checking mod_$EXT dependencies..."
			bash -e "$MODULES_PATH/mod_$EXT" check
			[ -d "${CHECK_PATH}" ] || mkdir "${CHECK_PATH}"
			touch "${CHECK_PATH}/mod_$EXT"
			echo "   Successfull."
			echo
		fi
	fi
	
	
	PENDINGTARGETS=''
	if [ ! -f "$MODULES_PATH/mod_$EXT" ]; then
		echo "   WARNING: Don't know how to handle file with $EXT extension."
		echo "            Skipping."
	else
		#bash -x "$MODULES_PATH/mod_$EXT" deps
		RAWDEPS=`bash -e "$MODULES_PATH/mod_$EXT" deps`
		# Removing duplicates
		RAWDEPS=`echo "$RAWDEPS" | sort -u`
		# Check for new render targets
		if [ ! -z "$RAWDEPS" ];then
		while read LINE; do
			DIR=`dirname "$LINE"`
			if [ ! -e "$DIR" ]; then
				# go one level down, because render result could be a 
				# sequence in dir which is not exists
				DIR=`dirname "$DIR"`
			fi
			EXTPROJECTROOT=`get_project_root "$DIR"`
			if [[ "$EXTPROJECTROOT" == "" ]]; then
				# Report files outside of the repo
				echo "   $LINE"
				echo "   WARNING: '$LINE' is not belongs to any project."
				echo "            Skipping."
				# Data packing
				if [ -e "$LINE" ]; then
					echo $(abspath "$LINE") >>"${PACKFILE}.lst"
				fi
			else
				if [ -d "`dirname "$LINE"`" ]; then
					pushd "`dirname "$LINE"`" >/dev/null
					DEPDIR=`pwd -P`
					popd >/dev/null
				else
					DEPDIR="`dirname "$LINE"`"
				fi
				LINE="$(relpath "`pwd -P`" "$DEPDIR")/`basename "$LINE"`"
				#LINE=$(relpath `pwd` $LINE)
				echo "   $LINE"
				if ( echo $DEPDIR | grep -E "^${EXTPROJECTROOT}/render" > /dev/null ); then
					
					#pushd `dirname $LINE` >/dev/null
					#DEPDIR=`pwd`
					#popd >/dev/null
					#DEP=$(relpath `pwd` $DEPDIR)/`basename $LINE`
					#LINE=`echo "$LINE"| sed -e "s/ /\\\\\\\\ /g"`
					#LINE=`echo "$LINE"| sed -e "s/\\\\\\ / /g"`
					echo "   INFO: Dependency '$LINE' defines another target."
					
					TARGETCANDIDATE=`echo $DEPDIR/$(basename "${LINE%.*}") | sed -e "s|^${EXTPROJECTROOT}/render/|${EXTPROJECTROOT}/|" `
					if [ ! -e "$TARGETCANDIDATE" ]; then
						TMP=$TARGETCANDIDATE
						TARGETCANDIDATE=`dirname "${TARGETCANDIDATE}"`
						TARGETCANDIDATE=${TARGETCANDIDATE%.*}
						echo "   INFO: Trying to fix '$TMP' to '$TARGETCANDIDATE'."
						
						if [ -d "$TARGETCANDIDATE" ]; then
							echo "         ERROR: Can't define target from directory."
						else
							if [ ! -e "$TARGETCANDIDATE" ]; then
								echo "   ERROR: Not found!"
								LINE=""
							else
								echo "         Successfull."
								LINE=`dirname "$LINE"`
							fi
						fi
					fi
					
					DEPS="$DEPS `escape "$LINE"`"
					
					if [ -e "$TARGETCANDIDATE" ] && [ ! -d "$TARGETCANDIDATE" ]; then
						#TARGETCANDIDATE=`echo "$TARGETCANDIDATE"| sed -e 's/ /\\\\\\\\ /g'`
						PENDINGTARGETS=$(echo -e "$PENDINGTARGETS\n$TARGETCANDIDATE")
					fi
				else
					if [ ! -e "$LINE" ]; then
						# Report non-existing files
						echo "   WARNING: '$LINE' is not exists and not produced by any target."
						echo "            Skipping."
					else
						#pushd `dirname $LINE` >/dev/null
						#DEPDIR=`pwd`
						#popd >/dev/null
						#DEPS="$DEPS $(relpath `pwd` $DEPDIR)/`basename $LINE`"
						#LINE=`echo "$LINE"| sed -e "s/ /\\\\\\ /g"`
						DEPS="$DEPS `escape "$LINE"`"
						# Data packing
						echo $(abspath "$LINE") >>"${PACKFILE}.lst"
					fi
				fi
			fi
		done < <( echo "$RAWDEPS" )
		fi
		
		export DEPS
		
		# Allow to override rules per file
		if [ -e "${TARGET}.make" ]; then
			echo "`escape "$RENDERPATH"`: `escape "$TARGET"` $DEPS" >> "$MAKEFILE"
			echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"`" >> "$MAKEFILE"
			echo "`escape "$RENDERPATH"`-clean:" >> "$MAKEFILE"
			echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"` clean" >> "$MAKEFILE"
		else
			bash -e "$MODULES_PATH/mod_$EXT" rules
		fi
		
		if [[ "$2" == 'deps' ]]; then
			echo ".PHONY: deps" >> "$MAKEFILE"
			echo "deps: $DEPS" >> "$MAKEFILE"
		fi
		
		echo ".PHONY: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
		echo "clean: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
		
		# Data packing
		echo $(abspath "$TARGET") >>"${PACKFILE}.lst"
		
		# Stereo rendering
		if [[ "$2" == 'stereo' ]]; then
			
			RENDERPATH_STEREO=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`-stereo
			RENDERPATH_AUDIO="`echo "$RENDERPATH" | sed -e "s|\.$FORMAT$|.mp2|"`"
			
			echo "stereo: `escape "$RENDERPATH_STEREO.mpg"`" >> "$MAKEFILE"
			echo ".PHONY: stereo" >> "$MAKEFILE"
			echo "`escape "$RENDERPATH_STEREO.mpg"`: `escape "$RENDERPATH"`" >> "$MAKEFILE"
			echo "	[ -d \"${PROJECTROOT}/render/stereo_cache/left\" ] || mkdir -p \"${PROJECTROOT}/render/stereo_cache/left\"" >> "$MAKEFILE"
			echo "	[ -d \"${PROJECTROOT}/render/stereo_cache/right\" ] || mkdir -p \"${PROJECTROOT}/render/stereo_cache/right\"" >> "$MAKEFILE"
			echo "	rsync -av --exclude render/ \"$PROJECTROOT/\" \"${PROJECTROOT}/render/stereo_cache/left/\"" >> "$MAKEFILE"
			echo "	rsync -av --exclude render/ \"$PROJECTROOT/\" \"${PROJECTROOT}/render/stereo_cache/right/\"" >> "$MAKEFILE"
			echo "	bash \"$SCRIPT_PATH/`basename $0`\" -f png -c Left -t $THREADS \"$PROJECTROOT/render/stereo_cache/left/$TARGETDIR/`basename "$1"`\"" >> "$MAKEFILE"
			echo "	bash \"$SCRIPT_PATH/`basename $0`\" -f png -c Right -t $THREADS \"$PROJECTROOT/render/stereo_cache/right/$TARGETDIR/`basename "$1"`\"" >> "$MAKEFILE"
			echo "	[ -d \"${RENDERPATH_STEREO}.png\" ] && rm -rf \"${RENDERPATH_STEREO}.png\" || true" >> "$MAKEFILE"
			echo "	mkdir \"${RENDERPATH_STEREO}.png\"" >> "$MAKEFILE"
			echo "	for file in \`cd \"${PROJECTROOT}/render/stereo_cache/right/render/$TARGETDIR/`basename "$1"`.png/\"; ls *.png\`; do convert \"$PROJECTROOT/render/stereo_cache/left/render/$TARGETDIR/`basename "$1"`.png/\$\$file\" \"$PROJECTROOT/render/stereo_cache/right/render/$TARGETDIR/`basename "$1"`.png/\$\$file\" +append \"${RENDERPATH_STEREO}.png/\$\$file\"; done" >> "$MAKEFILE"
			echo "	cp -f \"$PROJECTROOT/render/stereo_cache/left/render/$TARGETDIR/`basename "$1"`.png/file.lst\" \"${RENDERPATH_STEREO}.png/\"" >> "$MAKEFILE"
			echo "	-ffmpeg -y -i \"$RENDERPATH\" -vn -acodec copy \"$RENDERPATH_AUDIO\"" >> "$MAKEFILE"
			echo "	if [[ \`stat -c%s \"$RENDERPATH_AUDIO\"\` == 0 ]];then \\" >> "$MAKEFILE"
			echo "	ffmpeg -y -i \"${RENDERPATH_STEREO}.png/file.%04d.png\" -sameq -r $FPS \"${RENDERPATH_STEREO}.mpg\"; \\" >> "$MAKEFILE"
			echo "	else \\" >> "$MAKEFILE"
			echo "	ffmpeg -y -i \"${RENDERPATH_STEREO}.png/file.%04d.png\" -i \"$RENDERPATH_AUDIO\" -acodec copy -sameq -r $FPS \"${RENDERPATH_STEREO}.mpg\"; \\" >> "$MAKEFILE"
			echo "	fi" >> "$MAKEFILE"
		fi
		# "Snapshot" rule
		if [[ "$2" == 'snapshot' ]]; then
			[ -d "$PROJECTROOT/snapshots${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/snapshots${RENDERPREFIX}"
			
			# SCM detection
			pushd "$PROJECTROOT/${RENDERPREFIX}" >/dev/null
			if git rev-parse --git-dir > /dev/null  2>&1 ; then
				COMMITID=$(git show --pretty=oneline|head -n 1|sed 's/ .*//')
				COMMITID="-$COMMITID"
			fi
			popd >/dev/null
			
			SNAPSHOTPATH=$(relpath "`pwd -P`" "$PROJECTROOT/snapshots${RENDERPREFIX}")/`basename "$TARGET"`-`date +%Y%m%d-%H%M%S`${COMMITID}
			echo "snapshot: `escape "$SNAPSHOTPATH"`" >> "$MAKEFILE"
			echo "`escape "$SNAPSHOTPATH"`: `escape "$RENDERPATH"`" >> "$MAKEFILE"
			if [[ $FORMAT == 'mpg' ]] || [[ $FORMAT == 'avi' ]]; then
				echo "	cp -f \"${RENDERPATH}\" \"${SNAPSHOTPATH}.$FORMAT\"" >> "$MAKEFILE"
			else
				echo "	ffmpeg -y -i \"${RENDERPATH}/file.%04d.png\" -sameq -r $FPS \"${SNAPSHOTPATH}.avi\"" >> "$MAKEFILE"
			fi
			echo ".PHONY: snapshot" >> "$MAKEFILE"
		fi
		
		while read TARGET; do
			if [ ! -z "$TARGET" ];then
				write_rules "$TARGET"
			fi
		done < <( echo "$PENDINGTARGETS" )
	fi
	fi
}

OPT_KEEP=0
THREADS=1
CAMERA=""
while getopts "c:f:hkt:" OPTION
do
     case $OPTION in
         c)
             CAMERA="$OPTARG"
             ;;
         f)
             OPT_FORMAT="$OPTARG"
             ;;
         h)
             usage
             exit 1
             ;;
         k)
             OPT_KEEP=1
             ;;
         t)
             THREADS="$OPTARG"
             if [[ $THREADS == 0 ]]; then
                THREADS=''
             fi
             ;;
         ?)
             usage
             exit
             ;;
     esac
done

export CAMERA
export THREADS

shift $(($OPTIND - 1))

if [ -z "$1" ]; then
	echo
	echo "ERROR: Please specify filename to render. Aborting." >&2
	echo
	usage
	exit 1
fi

if [ ! -f "$1" ]; then
	echo
	echo "ERROR: No such file. Aborting." >&2
	echo
	exit 1
fi

if [[ "$2" == 'snapshot' ]]; then
	if ! ( which ffmpeg > /dev/null 2>&1 ); then
		echo "   FATAL: Can't find 'ffmpeg' binary!" >&2
		exit 1
	fi
fi

if [[ "$2" == 'stereo' ]]; then
	# Force output format to mpg
	OPT_FORMAT="mpg"
	# Check requirements
	if ! ( which ffmpeg > /dev/null 2>&1 ); then
		echo "   FATAL: Can't find 'ffmpeg' binary!" >&2
		exit 1
	fi
	if ! ( which convert > /dev/null 2>&1 ); then
		echo "   FATAL: ImageMagick not found. Aborting" >&2
		exit 1
	fi
fi

PROJECTROOT=$(get_project_root "`dirname \"$1\"`")
if [[ "$PROJECTROOT" == "" ]]; then
	exit 1
fi

CHECK_PATH="${PROJECTROOT}/render/tmp/check.$$"
export CHECK_PATH

[ -d "${PROJECTROOT}/render/tmp" ] || mkdir -p "${PROJECTROOT}/render/tmp"
MAKEFILE=${PROJECTROOT}/render/tmp/Makefile.$$
[ ! -e "$MAKEFILE" ] || rm "$MAKEFILE"
touch "$MAKEFILE"

PACKFILE="${PROJECTROOT}/packs/`basename \"$1\"`-`date +%Y%m%d-%H%M%S`.zip"
export PACKFILE
[ -d "${PROJECTROOT}/packs" ] || mkdir -p "${PROJECTROOT}/packs"

echo
echo "==============================================="
echo "       First stage: Analyzing files"
echo "==============================================="
echo

write_rules "$1" "$2" "$OPT_FORMAT"
echo ".PHONY: clean" >> "$MAKEFILE"
echo ".PHONY: pack" >> "$MAKEFILE"

# Processing file list for data pack
if [[ "$2" == 'pack' ]]; then
	# Removing duplicate lines
	sort "${PACKFILE}.lst" | uniq > "${PACKFILE}.lst2"
	
	# Some magic to detect common prefix
	# (thanks to Marlon Berlin - http://awk.freeshell.org/SedFAQ#toc23)
	PACKROOT=$(cat "${PACKFILE}.lst" | sed ':a;$!N;s/^\(.*\).*\n\1.*/\1/;ta')
	if [[ "$PACKROOT" != */ ]]; then
		PACKROOT=`dirname "$PACKROOT"`
		[[ "$PACKROOT" == */ ]] || PACKROOT="${PACKROOT}/"
	fi
	
	# Removing common prefix from the list
	rm "${PACKFILE}.lst"
	while read LINE; do
		echo ${LINE#$PACKROOT} >> "${PACKFILE}.lst"
	done < "${PACKFILE}.lst2"
	
	echo "pack:" >> "$MAKEFILE"
	echo "	cd \"$PACKROOT\"; cat \"${PACKFILE}.lst\" | zip -ur \"$PACKFILE\" -@" >> "$MAKEFILE"
fi

[[ $OPT_KEEP == 0 ]] || cp -f "$MAKEFILE" Makefile

echo
echo "==============================================="
echo "       Second stage: Rendering"
echo "==============================================="
echo

echo "Running make..."
make -f "$MAKEFILE" -j $THREADS $2
do_cleanup
