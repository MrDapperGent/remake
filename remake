#!/bin/bash

set -e

# First check required software
if ! ( which make > /dev/null 2>&1 ); then
	cat <<EOF
   FATAL: Can't find 'make' binary!
   
          Please install 'make' package using software manager of 
          your linux distributive.
EOF
	exit 1
fi

# Then initialize basic variables

SCRIPT_PATH="${BASH_SOURCE[0]}";
if([ -h "${SCRIPT_PATH}" ]) then
  while([ -h "${SCRIPT_PATH}" ]) do SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
pushd . > /dev/null
cd `dirname "${SCRIPT_PATH}"` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null
#SCRIPT_PATH=$(cd `dirname $0`; pwd)

MODULES_PATH=$SCRIPT_PATH/modules
if [ ! -d "$MODULES_PATH" ]; then
	#fix path for local installation
	MODULES_PATH="$SCRIPT_PATH/../lib/remake/modules"
	pushd "$MODULES_PATH" > /dev/null
	MODULES_PATH="`pwd`"
	popd > /dev/null
fi

TESTDATA_PATH=$SCRIPT_PATH/tests
if [ ! -d "$TESTDATA_PATH" ]; then
	#fix path for local installation
	TESTDATA_PATH="$SCRIPT_PATH/../share/remake/tests"
	pushd "$TESTDATA_PATH" > /dev/null
	TESTDATA_PATH="`pwd`"
	popd > /dev/null
fi
export TESTDATA_PATH

#Init traps
trap do_cleanup INT

escape()
{
echo "$1"| sed -e "s/ /\\\\\\ /g"
}

abspath(){
	readlink -m "$1"
}

usage()
{
cat << EOF
usage: $0 [options] file [command]

This script generates Makefile and renders your animation project taking all 
dependencies into account.

OPTIONS:
  -c <camera>   Select camera to render from (if applicable).
  -f <format>   Force output format.
  -h            Show this message.
  -i            Ignore all errors in commands executed to remake 
                files.
  -k            Keep Makefile so you can skip dependency detection 
                and re-invoke rendering by typing 'make'.
  -t <threads>  Specify the amount of rendering jobs to be run 
                in parallel. Use zero for no limit.
  -z            Don't use cache when retrieving dependencies.

COMMANDS:
  clean         Remove all rendered footage associated with the file.
  deps          Render all dependencies of the given file, but not 
                the file itself.
  pack          Pack into zip file together with all dependencies.
                Resulting file will reside the 'packs/' subdirectory
                of the project tree.
  snapshot      Additionally save snapshot of the current rendering 
                as video file in the 'snapshots/' subdirectory of
                the project tree.
  stereo        Render stereoscopic 3D (side-by-side).
EOF
}

relpath(){
	if [[ "$1" == "$2" ]]
	then
		echo "."
	fi

	IFS="/"

	current=($1)
	absolute=($2)

	abssize=${#absolute[@]}
	cursize=${#current[@]}

	while [[ ${absolute[$level]} == ${current[$level]} ]]
	do
		(( level++ ))
		if (( level > abssize || level > cursize ))
		then
			break
		fi
	done

	for ((i = level; i < cursize; i++))
	do
		if ((i > level))
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath".."
	done

	for ((i = level; i < abssize; i++))
	do
		if [[ -n $newpath ]]
		then
			newpath=$newpath"/"
		fi
		newpath=$newpath${absolute[i]}
	done

	echo "$newpath"
}

get_project_root() {
	if [ -d "$1" ]; then
		pushd "$1" >/dev/null
		TESTDIR=`pwd -P`
		popd >/dev/null
	else
		TESTDIR="$1"
	fi
	if [ -f "$TESTDIR/remake.conf" ]; then
		echo $TESTDIR
	else
		if [[ "$TESTDIR" == '/' ]]; then
			exit
		fi
		get_project_root "`dirname \"$TESTDIR\"`"
	fi
}

do_cleanup(){
	echo
	echo "Cleaning up..."
	rm -f "$MAKEFILE"
	[ ! -e "${PACKFILE}.lst" ] || rm "${PACKFILE}.lst"
	[ ! -e "${PACKFILE}.lst2" ] || rm "${PACKFILE}.lst2"
	# Remove modules check flags
	rm -rf "${CHECK_PATH}" || true
}

write_rules(){
	if [ -z $2 ]; then
		DOWRITE=1
	else
		DOWRITE=$2
	fi
	
	PROJECTROOT=$(get_project_root "`dirname \"$1\"`")
	if [[ "$PROJECTROOT" == "" ]]; then
		echo "   ERROR: Not a 'remake' project." 1>&2
		exit 1
	fi
	pushd "`dirname "$1"`" >/dev/null
	RENDERPREFIX=$(pwd -P | sed -e "s|$PROJECTROOT||")
	[ -d "$PROJECTROOT/render${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/render${RENDERPREFIX}"
	# TARGETDIR - path to TARGET relative to project root
	TARGETDIR=$(relpath "$PROJECTROOT" "`pwd -P`")
	popd  >/dev/null
	
	CONFIGPATH=$(relpath "`pwd -P`" "$PROJECTROOT/remake.conf")
	# Data packing
	[ -d "$PROJECTROOT/packs" ] || mkdir -p "$PROJECTROOT/packs"
	echo "${PROJECTROOT}/remake.conf" >>"${PACKFILE}.lst"
	
	# Ensure that render dir ignored by git
	[ -e "$PROJECTROOT/.gitignore" ] || touch "$PROJECTROOT/.gitignore"
	( cat "$PROJECTROOT/.gitignore" | egrep "render/\*" > /dev/null ) || ( echo "render/*" >> "$PROJECTROOT/.gitignore" )
	( cat "$PROJECTROOT/.gitignore" | egrep "snapshots/\*" > /dev/null ) || ( echo "snapshots/*" >> "$PROJECTROOT/.gitignore" )
	( cat "$PROJECTROOT/.gitignore" | egrep "packs/\*" > /dev/null ) || ( echo "packs/*" >> "$PROJECTROOT/.gitignore" )
	
	TARGET=$(relpath "`pwd -P`" "$PROJECTROOT/$TARGETDIR")/`basename "$1"`
	EXT=${TARGET##*.}
	
	# Defaults
	FORMAT=png
	UPDATE=0
	
	# Re-reading config
	. "$PROJECTROOT/remake.conf"
	
	if [ -z $AUDIO_RATE ]; then
		AUDIO_RATE=48000
	fi
	
	DEPS="`escape "$CONFIGPATH"` "
	SINGLE=''
	
	export FORMAT
	
	# give module a chance to override format
	if [ -f "$MODULES_PATH/mod_$EXT" ]; then
		FORMAT=`bash -e "$MODULES_PATH/mod_$EXT" format`
	fi
	
	# Looking for extra settings
	if [ -e "${TARGET}.conf" ]; then
		. "${TARGET}.conf"
		DEPS="$DEPS `escape "${TARGET}.conf"` "
		# Data packing
		echo $(abspath "${TARGET}.conf") >>"${PACKFILE}.lst"
	fi
	
	# Format can be overriden by commandline option
	if [ ! -z "$4" ]; then
		FORMAT="$4"
	fi
	
	# Format should be forced to PNG if snapshot is requested
	if [[ "$3" == 'snapshot' && $FORMAT != 'mpg' && $FORMAT != 'avi' ]]; then
		FORMAT=png
	fi
	
	if [ $DOWRITE == 1 ]; then
		RENDERPATH=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`.$FORMAT
	else
		RENDERPATH=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`.dep
	fi
	
	# check if rules for this target are already written
	ESCAPED_RENDERPATH="`escape "$RENDERPATH"`"
	ESCAPED_RENDERPATH="`escape "$ESCAPED_RENDERPATH"`" # Twice!!!
	if ! ( cat "$MAKEFILE" | grep -E "^$ESCAPED_RENDERPATH:" >/dev/null ); then
	
	echo "Retrieving deps for '$TARGET'..."
	
	export WIDTH
	export HEIGHT
	export FPS
	export SINGLE
	export FROM
	export TO
	export UPDATE
	export AUDIO_RATE
	
	export TARGET
	export RENDERPATH
	export PROJECTROOT
	
	export MAKEFILE
	
	# check module requirements
	if [ -f "$MODULES_PATH/mod_$EXT" ]; then
		if [ ! -e "${CHECK_PATH}/mod_$EXT" ]; then
			echo
			echo "Checking mod_$EXT dependencies..."
			bash -e "$MODULES_PATH/mod_$EXT" check
			[ -d "${CHECK_PATH}" ] || mkdir "${CHECK_PATH}"
			touch "${CHECK_PATH}/mod_$EXT"
			echo "   Successfull."
			echo
		fi
	fi
	
	
	PENDINGTARGETS='\n'
	PENDINGTARGETS_CACHE='\n'
	DEPS_CACHE='\n'
	
	# Looking for cachefile
	CACHE=''
	CACHE_VERSION=2
	CACHEFILE="${RENDERPATH%.*}.deps"
	TARGETDATE=`stat -c %Y "$TARGET"`
	if [[ $OPT_NOCACHE == 0 ]]; then
		if [ -f "$CACHEFILE" ]; then
			CACHEFILEVERSION=`sed '1q;d' "$CACHEFILE"`
			if [[ "$CACHE_VERSION" == "$CACHEFILEVERSION" ]]; then
				CACHEDATE=`sed '2q;d' "$CACHEFILE"`
				if [[ $TARGETDATE == $CACHEDATE ]]; then
					CACHE='found'
				fi
			fi
		fi
	fi
	
	if [ ! -z $CACHE ]; then
		echo "   Cache file found."
		
		DEPS_CACHE="`sed '3q;d' "$CACHEFILE"` "
		while read LINE; do
			if [ ! -z "$LINE" ]; then
				pushd "`dirname "$TARGET"`" >/dev/null
				LINE="`abspath "$LINE"`"
				popd >/dev/null
				
				if [ -e "$LINE" ]; then    #it's possible the file isn't exists anymore
					# Data packing
					DIR=`dirname "$LINE"`
					if [ ! -e "$DIR" ]; then
						# go one level down, because render result could be a 
						# sequence in dir which is not exists
						DIR=`dirname "$DIR"`
					fi
					EXTPROJECTROOT=`get_project_root "$DIR"`
					if [[ "$EXTPROJECTROOT" != "" ]] && ( echo $LINE | grep -E "^${EXTPROJECTROOT}/render" > /dev/null ); then 
						true # no files from render directory!
					else
						echo $LINE >>"${PACKFILE}.lst"
					fi
				
					LINE="$(relpath "`pwd -P`" "$LINE")"
					ESCAPED_LINE=`escape "$LINE"`
					DEPS="${DEPS}${ESCAPED_LINE} "
				fi
			fi
		done < <( echo -e "$DEPS_CACHE" )
		
		PENDINGTARGETS_CACHE=`sed '4q;d' "$CACHEFILE"`
		while read TARGETCANDIDATE; do
			if [ ! -z "$TARGETCANDIDATE" ]; then
				DOWRITE_CACHE=${TARGETCANDIDATE%%.*}
				TARGETCANDIDATE=${TARGETCANDIDATE#*.}
				pushd "`dirname "$TARGET"`" >/dev/null
				TARGETCANDIDATE="`abspath "$TARGETCANDIDATE"`"
				popd >/dev/null
				
				# Data packing
				echo $TARGETCANDIDATE >>"${PACKFILE}.lst"
				
				PENDINGTARGETS="${PENDINGTARGETS}${DOWRITE_CACHE}.${TARGETCANDIDATE}\n"
			fi
		done < <( echo -e "$PENDINGTARGETS_CACHE" )
	elif [ ! -f "$MODULES_PATH/mod_$EXT" ]; then
		echo "   WARNING: Don't know how to handle file with $EXT extension."
		echo "            Skipping."
	else
		#bash -x "$MODULES_PATH/mod_$EXT" deps
		RAWDEPS=`bash -e "$MODULES_PATH/mod_$EXT" deps`
		# Removing duplicates
		RAWDEPS=`echo "$RAWDEPS" | sort -u`
		# Check for new render targets
		if [ ! -z "$RAWDEPS" ];then
		while read LINE; do
			DIR=`dirname "$LINE"`
			if [ ! -e "$DIR" ]; then
				# go one level down, because render result could be a 
				# sequence in dir which is not exists
				DIR=`dirname "$DIR"`
			fi
			EXTPROJECTROOT=`get_project_root "$DIR"`
			if [[ "$EXTPROJECTROOT" == "" ]]; then
				# Report files outside of the repo
				[ -z $DEBUG ] || echo "   $LINE"
				echo "   WARNING: '$LINE' is not belongs to any project."
				echo "            Skipping."
				# Data packing
				if [ -e "$LINE" ]; then
					echo $(abspath "$LINE") >>"${PACKFILE}.lst"
				fi
			else
				if [ -d "`dirname "$LINE"`" ]; then
					pushd "`dirname "$LINE"`" >/dev/null
					DEPDIR=`pwd -P`
					popd >/dev/null
				else
					DEPDIR="`dirname "$LINE"`"
				fi
				LINE="$(relpath "`pwd -P`" "$DEPDIR")/`basename "$LINE"`"
				#LINE=$(relpath `pwd` $LINE)
				echo "   $LINE"
				if ( echo $DEPDIR | grep -E "^${EXTPROJECTROOT}/render" > /dev/null ); then
					
					#pushd `dirname $LINE` >/dev/null
					#DEPDIR=`pwd`
					#popd >/dev/null
					#DEP=$(relpath `pwd` $DEPDIR)/`basename $LINE`
					#LINE=`echo "$LINE"| sed -e "s/ /\\\\\\\\ /g"`
					#LINE=`echo "$LINE"| sed -e "s/\\\\\\ / /g"`
					[ -z $DEBUG ] || echo "   INFO: Dependency '$LINE' defines another target."
					
					TARGETCANDIDATE=`echo $DEPDIR/$(basename "${LINE%.*}") | sed -e "s|^${EXTPROJECTROOT}/render/|${EXTPROJECTROOT}/|" `
					if [ ! -e "$TARGETCANDIDATE" ]; then
						TMP=$TARGETCANDIDATE
						TARGETCANDIDATE=`dirname "${TARGETCANDIDATE}"`
						TARGETCANDIDATE=${TARGETCANDIDATE%.*}
						[ -z $DEBUG ] || echo "   INFO: Trying to fix '$TMP' to '$TARGETCANDIDATE'."
						
						if [ -d "$TARGETCANDIDATE" ]; then
							[ -z $DEBUG ] || echo "         ERROR: Can't define target from directory."
							LINE=""
						else
							if [ ! -e "$TARGETCANDIDATE" ]; then
								echo "   ERROR: Not found!"
								LINE=""
							else
								[ -z $DEBUG ] || echo "         Successfull."
								LINE=`dirname "$LINE"`
							fi
						fi
					fi
					
					if [ ! -z "$LINE" ]; then
					
					ESCAPED_LINE=`escape "$LINE"`
					if ! ( echo "$DEPS" | grep -F " $ESCAPED_LINE " > /dev/null ); then
						DEPS="${DEPS}${ESCAPED_LINE} "
						# Writing cache
						LINE=`abspath "$LINE"`
						pushd "`dirname "$TARGET"`" >/dev/null
						DEPS_CACHE="${DEPS_CACHE}$(relpath "`pwd -P`" "$LINE")\n"
						popd >/dev/null
					fi
					
					if [ -e "$TARGETCANDIDATE" ] && [ ! -d "$TARGETCANDIDATE" ]; then
						#TARGETCANDIDATE=`echo "$TARGETCANDIDATE"| sed -e 's/ /\\\\\\\\ /g'`
						if ! ( echo $PENDINGTARGETS | grep -E "\\\\n1.${TARGETCANDIDATE}\\\\n" > /dev/null ); then
							PENDINGTARGETS="${PENDINGTARGETS}1.${TARGETCANDIDATE}\n"

							pushd "`dirname "$TARGET"`" >/dev/null
							PENDINGTARGETS_CACHE="${PENDINGTARGETS_CACHE}1.$(relpath "`pwd -P`" "$TARGETCANDIDATE")\n"
							popd >/dev/null
						fi
					fi
					
					fi # ! -z "$LINE"
				else
					if [ ! -e "$LINE" ]; then
						# Report non-existing files
						echo "   WARNING: '$LINE' is not exists and not produced by any target."
						echo "            Skipping."
					else
					
						# Data packing
						echo $(abspath "$LINE") >>"${PACKFILE}.lst"
						
						LINE_EXT=${LINE##*.}
						if [ -f "$MODULES_PATH/mod_$LINE_EXT" ]; then
							TARGETCANDIDATE=`abspath "${LINE}"`
							if ! ( echo $PENDINGTARGETS | grep -E "\\\\n0.${TARGETCANDIDATE}\\\\n" > /dev/null ); then
								PENDINGTARGETS="${PENDINGTARGETS}0.${TARGETCANDIDATE}\n"
								pushd "`dirname "$TARGET"`" >/dev/null
								PENDINGTARGETS_CACHE="${PENDINGTARGETS_CACHE}0.$(relpath "`pwd -P`" "$TARGETCANDIDATE")\n"
								popd >/dev/null
							fi
							pushd "$DEPDIR" >/dev/null
							DEP_RENDERPREFIX=$(pwd -P | sed -e "s|$EXTPROJECTROOT||")
							[ -d "$EXTPROJECTROOT/render${DEP_RENDERPREFIX_DEP}" ] || mkdir -p "$EXTPROJECTROOT/render${DEP_RENDERPREFIX}"
							popd  >/dev/null
							LINE=$(relpath "`pwd -P`" "$EXTPROJECTROOT/render${DEP_RENDERPREFIX}")/`basename "$LINE"`.dep
						fi
						
						ESCAPED_LINE=`escape "$LINE"`
						if ! ( echo $DEPS | grep -F " $ESCAPED_LINE " > /dev/null ); then
							DEPS="${DEPS}${ESCAPED_LINE} "
							# Writing cache
							LINE=`abspath "$LINE"`
							pushd "`dirname "$TARGET"`" >/dev/null
							DEPS_CACHE="${DEPS_CACHE}$(relpath "`pwd -P`" "$LINE")\n"
							popd >/dev/null
						fi
						
					fi
				fi
			fi
		done < <( echo "$RAWDEPS" )
		# Write cache
		echo $CACHE_VERSION > "$CACHEFILE"
		echo $TARGETDATE >> "$CACHEFILE"
		echo $DEPS_CACHE >> "$CACHEFILE"
		echo $PENDINGTARGETS_CACHE >> "$CACHEFILE"
		fi
	fi
	
	if [ $DOWRITE == 0 ]; then
		echo "`escape "$RENDERPATH"`: `escape "$TARGET"` $DEPS" >> "$MAKEFILE"
		echo "	touch \"$RENDERPATH\"" >> "$MAKEFILE"
		echo "`escape "$RENDERPATH"`-clean:" >> "$MAKEFILE"
		echo "	[ ! -e \"$RENDERPATH\" ] || rm \"$RENDERPATH\"" >> "$MAKEFILE"
		echo ".PHONY: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
		echo "clean: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
	else
		
	export DEPS
	
	# Allow to override rules per file
	if [ -e "${TARGET}.make" ]; then
		echo "`escape "$RENDERPATH"`: `escape "$TARGET"` $DEPS" >> "$MAKEFILE"
		echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"`" >> "$MAKEFILE"
		echo "`escape "$RENDERPATH"`-clean:" >> "$MAKEFILE"
		echo "	cd `dirname "$RENDERPATH"` && make -f `basename \"${TARGET}.make\"` clean" >> "$MAKEFILE"
	else
		bash -e "$MODULES_PATH/mod_$EXT" rules
	fi
	
	if [[ "$3" == 'deps' ]]; then
		echo ".PHONY: deps" >> "$MAKEFILE"
		echo "deps: $DEPS" >> "$MAKEFILE"
	fi
	
	echo ".PHONY: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
	echo "clean: `escape "$RENDERPATH"`-clean" >> "$MAKEFILE"
	
	# Data packing
	echo $(abspath "$TARGET") >>"${PACKFILE}.lst"
	
	# Stereo rendering
	if [[ "$3" == 'stereo' ]]; then
		
		RENDERPATH_STEREO=$(relpath "`pwd -P`" "$PROJECTROOT/render${RENDERPREFIX}")/`basename "$TARGET"`-stereo
		RENDERPATH_AUDIO="`echo "$RENDERPATH" | sed -e "s|\.$FORMAT$|.mp2|"`"
		
		echo "stereo: `escape "$RENDERPATH_STEREO.mpg"`" >> "$MAKEFILE"
		echo ".PHONY: stereo" >> "$MAKEFILE"
		echo "`escape "$RENDERPATH_STEREO.mpg"`: `escape "$RENDERPATH"`" >> "$MAKEFILE"
		echo "	[ -d \"${PROJECTROOT}/render/stereo_cache/left\" ] || mkdir -p \"${PROJECTROOT}/render/stereo_cache/left\"" >> "$MAKEFILE"
		echo "	[ -d \"${PROJECTROOT}/render/stereo_cache/right\" ] || mkdir -p \"${PROJECTROOT}/render/stereo_cache/right\"" >> "$MAKEFILE"
		echo "	rsync -av --exclude render/ \"$PROJECTROOT/\" \"${PROJECTROOT}/render/stereo_cache/left/\"" >> "$MAKEFILE"
		echo "	rsync -av --exclude render/ \"$PROJECTROOT/\" \"${PROJECTROOT}/render/stereo_cache/right/\"" >> "$MAKEFILE"
		echo "	bash \"$SCRIPT_PATH/`basename $0`\" -f png -c Left -t $THREADS \"$PROJECTROOT/render/stereo_cache/left/$TARGETDIR/`basename "$1"`\"" >> "$MAKEFILE"
		echo "	bash \"$SCRIPT_PATH/`basename $0`\" -f png -c Right -t $THREADS \"$PROJECTROOT/render/stereo_cache/right/$TARGETDIR/`basename "$1"`\"" >> "$MAKEFILE"
		echo "	[ -d \"${RENDERPATH_STEREO}.png\" ] && rm -rf \"${RENDERPATH_STEREO}.png\" || true" >> "$MAKEFILE"
		echo "	mkdir \"${RENDERPATH_STEREO}.png\"" >> "$MAKEFILE"
		echo "	for file in \`cd \"${PROJECTROOT}/render/stereo_cache/right/render/$TARGETDIR/`basename "$1"`.png/\"; ls *.png\`; do convert \"$PROJECTROOT/render/stereo_cache/left/render/$TARGETDIR/`basename "$1"`.png/\$\$file\" \"$PROJECTROOT/render/stereo_cache/right/render/$TARGETDIR/`basename "$1"`.png/\$\$file\" +append \"${RENDERPATH_STEREO}.png/\$\$file\"; done" >> "$MAKEFILE"
		echo "	cp -f \"$PROJECTROOT/render/stereo_cache/left/render/$TARGETDIR/`basename "$1"`.png/file.lst\" \"${RENDERPATH_STEREO}.png/\"" >> "$MAKEFILE"
		echo "	-ffmpeg -y -i \"$RENDERPATH\" -vn -acodec copy \"$RENDERPATH_AUDIO\"" >> "$MAKEFILE"
		echo "	if [[ \`stat -c%s \"$RENDERPATH_AUDIO\"\` == 0 ]];then \\" >> "$MAKEFILE"
		echo "	ffmpeg -y -i \"${RENDERPATH_STEREO}.png/file.%04d.png\" -sameq -r $FPS \"${RENDERPATH_STEREO}.mpg\"; \\" >> "$MAKEFILE"
		echo "	else \\" >> "$MAKEFILE"
		echo "	ffmpeg -y -i \"${RENDERPATH_STEREO}.png/file.%04d.png\" -i \"$RENDERPATH_AUDIO\" -acodec copy -sameq -r $FPS \"${RENDERPATH_STEREO}.mpg\"; \\" >> "$MAKEFILE"
		echo "	fi" >> "$MAKEFILE"
	fi
	# "Snapshot" rule
	if [[ "$3" == 'snapshot' ]]; then
		[ -d "$PROJECTROOT/snapshots${RENDERPREFIX}" ] || mkdir -p "$PROJECTROOT/snapshots${RENDERPREFIX}"
		
		# SCM detection
		pushd "$PROJECTROOT/${RENDERPREFIX}" >/dev/null
		if git rev-parse --git-dir > /dev/null  2>&1 ; then
			COMMITID=$(git show --pretty=oneline|head -n 1|sed 's/ .*//')
			COMMITID="-$COMMITID"
		fi
		popd >/dev/null
		
		SNAPSHOTPATH=$(relpath "`pwd -P`" "$PROJECTROOT/snapshots${RENDERPREFIX}")/`basename "$TARGET"`-`date +%Y%m%d-%H%M%S`${COMMITID}
		echo "snapshot: `escape "$SNAPSHOTPATH"`" >> "$MAKEFILE"
		echo "`escape "$SNAPSHOTPATH"`: `escape "$RENDERPATH"`" >> "$MAKEFILE"
		if [[ $FORMAT == 'mpg' ]] || [[ $FORMAT == 'avi' ]]; then
			echo "	cp -f \"${RENDERPATH}\" \"${SNAPSHOTPATH}.$FORMAT\"" >> "$MAKEFILE"
		else
			echo "	ffmpeg -y -i \"${RENDERPATH}/file.%04d.png\" -sameq -r $FPS \"${SNAPSHOTPATH}.avi\"" >> "$MAKEFILE"
		fi
		echo ".PHONY: snapshot" >> "$MAKEFILE"
	fi
	fi  # DOWRITE == 1
	
	while read TARGET; do
		if [ ! -z "$TARGET" ];then
			DOWRITE=${TARGET%%.*}
			TARGET=${TARGET#*.}
			write_rules "$TARGET" $DOWRITE
		fi
	done < <( echo -e "$PENDINGTARGETS" )
	
	fi
}

OPT_KEEP=0
OPT_NOCACHE=0
OPT_IGNORE_ERRORS=''
THREADS=1
CAMERA=""
while getopts "c:f:hikt:z" OPTION
do
     case $OPTION in
         c)
             CAMERA="$OPTARG"
             ;;
         f)
             OPT_FORMAT="$OPTARG"
             ;;
         h)
             usage
             exit 1
             ;;
         i)
             OPT_IGNORE_ERRORS='-i'
             ;;
         k)
             OPT_KEEP=1
             ;;
         t)
             THREADS="$OPTARG"
             if [[ $THREADS == 0 ]]; then
                THREADS=''
             fi
             ;;
         z)
             OPT_NOCACHE=1
             ;;
         ?)
             usage
             exit
             ;;
     esac
done

export CAMERA
export THREADS

shift $(($OPTIND - 1))

if [ -z "$1" ]; then
	echo
	echo "ERROR: Please specify filename to render. Aborting." >&2
	echo
	usage
	exit 1
fi

if [ ! -f "$1" ]; then
	echo
	echo "ERROR: No such file. Aborting." >&2
	echo
	exit 1
fi

if [[ "$3" == 'snapshot' ]]; then
	if ! ( which ffmpeg > /dev/null 2>&1 ); then
		echo "   FATAL: Can't find 'ffmpeg' binary!" >&2
		exit 1
	fi
fi

if [[ "$3" == 'stereo' ]]; then
	# Force output format to mpg
	OPT_FORMAT="mpg"
	# Check requirements
	if ! ( which ffmpeg > /dev/null 2>&1 ); then
		echo "   FATAL: Can't find 'ffmpeg' binary!" >&2
		exit 1
	fi
	if ! ( which convert > /dev/null 2>&1 ); then
		echo "   FATAL: ImageMagick not found. Aborting" >&2
		exit 1
	fi
fi

PROJECTROOT=$(get_project_root "`dirname \"$1\"`")
if [[ "$PROJECTROOT" == "" ]]; then
	echo "   ERROR: Not a 'remake' project." 1>&2
	exit 1
fi

CHECK_PATH="${PROJECTROOT}/render/tmp/check.$$"
export CHECK_PATH

[ -d "${PROJECTROOT}/render/tmp" ] || mkdir -p "${PROJECTROOT}/render/tmp"
MAKEFILE=${PROJECTROOT}/render/tmp/Makefile.$$
[ ! -e "$MAKEFILE" ] || rm "$MAKEFILE"
touch "$MAKEFILE"

PACKFILE="${PROJECTROOT}/packs/`basename \"$1\"`-`date +%Y%m%d-%H%M%S`.zip"
export PACKFILE
[ -d "${PROJECTROOT}/packs" ] || mkdir -p "${PROJECTROOT}/packs"

echo
echo "==============================================="
echo "       First stage: Analyzing files"
echo "==============================================="
echo

write_rules "$1" 1 "$2" "$OPT_FORMAT"
echo ".PHONY: clean" >> "$MAKEFILE"
echo ".PHONY: pack" >> "$MAKEFILE"

# Processing file list for data pack
if [[ "$2" == 'pack' ]]; then
	# Removing duplicate lines
	sort "${PACKFILE}.lst" | uniq > "${PACKFILE}.lst2"
	
	# Some magic to detect common prefix
	# (thanks to Marlon Berlin - http://awk.freeshell.org/SedFAQ#toc23)
	PACKROOT=$(cat "${PACKFILE}.lst" | sed ':a;$!N;s/^\(.*\).*\n\1.*/\1/;ta')
	if [[ "$PACKROOT" != */ ]]; then
		PACKROOT=`dirname "$PACKROOT"`
		[[ "$PACKROOT" == */ ]] || PACKROOT="${PACKROOT}/"
	fi
	
	# Removing common prefix from the list
	rm "${PACKFILE}.lst"
	while read LINE; do
		echo ${LINE#$PACKROOT} >> "${PACKFILE}.lst"
	done < "${PACKFILE}.lst2"
	
	echo "pack:" >> "$MAKEFILE"
	echo "	cd \"$PACKROOT\"; cat \"${PACKFILE}.lst\" | zip -ur \"$PACKFILE\" -@" >> "$MAKEFILE"
fi

[[ $OPT_KEEP == 0 ]] || cp -f "$MAKEFILE" Makefile

echo
echo "==============================================="
echo "       Second stage: Rendering"
echo "==============================================="
echo

echo "Running make..."
make -f "$MAKEFILE" -j $THREADS $OPT_IGNORE_ERRORS $2
do_cleanup
